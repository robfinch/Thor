#pragma once
#include "clsDevice.h"
// Keyboard Device Emulation
//
// The keyboard controller code loops around until there are no more scan
// codes available from the keyboard. In real life an interrupt signal is
// generated by each scan code sent by the keyboard. There is no hardware
// buffering of scan-codes. In the emulation only a single emulation 
// interrupt is generated for a keypress(button) event and multiple scan
// codes are buffered. Rather than emulate the keyboard interface more
// closely the emulation is simplified and the driver software recognizes
// the way the emulation works. Otherwise it might be necessary to
// implement the keyboard interface in it's own thread with calls to
// Sleep() between each scan-code transmission.
// It should work because the interrupt routine checks for additional
// scan codes during it's processing. This is a case where the software
// for the system is designed around supporting the emulator.
// In real life there should never be two scan-codes sent by the keyboard
// close enough together for the loop in the keyboard code to be 
// effective. The loop is harmless enough as the scan-code status
// needs to be tested anyway. Whether its a while() or an if() is
// irrelevant.

class clsKeyboard : public clsDevice
{
	unsigned __int8 buffer[32];
	int head;
	int tail;
public:
	volatile unsigned __int8 scancode;
	volatile unsigned __int8 status;
	clsKeyboard(void);
	~clsKeyboard(void);
	bool IsSelected(unsigned int ad) { return ((ad & 0xFFFFFFF0)==0xFFDC0000); };
	void Put(unsigned __int8 sc) {
		scancode = sc;
		buffer[head] = sc;
		head++;
		head &= 31;
	};
	unsigned __int8 Get() {
		unsigned __int8 sc;

		sc = 0;
		if (head != tail) {
			sc = buffer[tail];
			tail++;
			tail &= 31;
		}
		return sc;
	};
	unsigned __int8 Peek(int amt) {
		unsigned __int8 sc;
		int ndx;

		ndx = tail + amt;
		ndx &= 31;
		sc = buffer[ndx];
		return sc;
	};
	unsigned __int8 GetStatus() {
		if (head != tail)
			return 0x80;
		else
			return 0x00;
	};
};

