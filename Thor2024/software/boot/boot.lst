Sections:
00: ".bss" (0-14)
01: ".data" (0-A)
02: ".text" (0-A00)
03: ".rodata" (0-10000)


Source: "boot.asm"
                                    	     1: # boot.asm Thor2024 assembly language
                                    	     2: 
                                    	     3: 	.bss
00:0000000000000000 00              	     4: 	.space	10
00:0000000000000001 *
                                    	     5: .set ary,0xFFFC0000
                                    	     6: .set txtscreen,0xFEC00000
                                    	     7: .set leds,0xFEDFFF00
                                    	     8: .set keybd,0xFEDCFE00
                                    	     9: .set rand,0xFEE1FD00
                                    	    10: .set CTRLH,8
                                    	    11: .set CTRLX,24
                                    	    12: 
                                    	    13: .set CursorRow,0xFFFC0400
                                    	    14: .set CursorCol,0xFFFC0401
                                    	    15: .set TextRows,0xFFFC0402
                                    	    16: .set TextCols,0xFFFC0403
                                    	    17: .set TextCurpos,0xFFFC0404
                                    	    18: .set TextScr,0xFFFC0408
                                    	    19: .set TextAttr,0xFFFC0410
                                    	    20: 
                                    	    21: .extern	SerialInit
                                    	    22: .extern SerialPutString
                                    	    23: .extern SerialTest
                                    	    24: 
                                    	    25: 	.data
01:0000000000000000 00              	    26: 	.space	10
01:0000000000000001 *
                                    	    27: 
                                    	    28: #	.org	0xFFFFFFFFFFFD0000
                                    	    29: 	.text
                                    	    30: #	.align	0
                                    	    31: start:
02:0000000000000000 0402F8FF07      	    32: 	ldi t0,-1
02:0000000000000005 520200E0077C00FF	    33: 	stt.io t0,leds
02:000000000000000D DFFE
02:000000000000000F 04020000007C0000	    34: 	ldi	t0,txtscreen
02:0000000000000017 C0FE7C00000000
02:000000000000001E 52020081007C0804	    35: 	stt t0,TextScr
02:0000000000000026 FCFF
02:0000000000000028 04020000007C0000	    36: 	ldi t0,0x43FFFFE0003F0000		# white foreground, blue background
02:0000000000000030 3F007CE0FFFF43
02:0000000000000037 53020082007C1004	    37: 	sto t0,TextAttr
02:000000000000003F FCFF
02:0000000000000041 0402000100      	    38: 	ldi t0,32
02:0000000000000046 50024080007C0204	    39: 	stb t0,TextRows
02:000000000000004E FCFF
02:0000000000000050 0402000200      	    40: 	ldi t0,64
02:0000000000000055 50026080007C0304	    41: 	stb t0,TextCols
02:000000000000005D FCFF
02:000000000000005F 50000080007C0004	    42: 	stb r0,CursorRow
02:0000000000000067 FCFF
02:0000000000000069 50002080007C0104	    43: 	stb r0,CursorCol
02:0000000000000071 FCFF
02:0000000000000073 51008080007C0404	    44: 	stw r0,TextCurpos
02:000000000000007B FCFF
                                    	    45: 	
02:000000000000007D A0C2010000      	    46: 	bsr	Delay3s
02:0000000000000082 A0720B0000      	    47: 	bsr SerialInit
02:0000000000000087 A094110000      	    48: 	bsr SerialTest
02:000000000000008C A0EA010000      	    49: 	bsr ClearScreen
                                    	    50: 
                                    	    51: #	ldi	a0,msgStart
                                    	    52: #	bsr	SerialPutString
02:0000000000000091 841E0000007C0000	    53: 	ldi gp,0xffff0000
02:0000000000000099 FFFF7C00000000
02:00000000000000A0 CAA0070000      	    54: 	lda a0,msgStart[gp]
02:00000000000000A5 A0DC0A0000      	    55: 	bsr DisplayString
                                    	    56: 
02:00000000000000AA 8F03000000      	    57: 	mov t3,r0
02:00000000000000AF 0403400100      	    58: 	ldi t2,40
                                    	    59: .st2:
02:00000000000000B4 570038C0007C0000	    60: 	sto r0,0xfffc0000[r0+t3]
02:00000000000000BC FCFF
02:00000000000000BE 84E3400000      	    61: 	add t3,t3,8
02:00000000000000C3 28E830F8FF      	    62: 	blt t3,t2,.st2
                                    	    63: 	
02:00000000000000C8 0701088001      	    64: 	csrrd r2,r0,0x3001	# get the thread number
02:00000000000000CD 0841780000      	    65: 	and r2,r2,15				# 0 to 3
02:00000000000000D2 0402080000      	    66: 	ldi t0,1
02:00000000000000D7 2750204000      	    67: 	bne r2,t0,stall			# Allow only thread 1 to work
                                    	    68: 
02:00000000000000DC 0401E80700      	    69: 	ldi r2,0xFD
02:00000000000000E1 0401080000      	    70: 	ldi r2,0x01					# x = 1
02:00000000000000E6 52010000007C0000	    71: 	stt r2,ary@got
02:00000000000000EE FCFF
                                    	    72: 
02:00000000000000F0 8401800000      	    73: 	ldi r3,0x10		# calculates 16th fibonacci number (13 = D in hex) (CHANGE HERE IF YOU WANT TO CALCULATE ANOTHER NUMBER)
02:00000000000000F5 8260000800      	    74: 	or r1,r3,r0	# transfer y register to accumulator
02:00000000000000FA 8461E8FF07      	    75: 	add r3,r3,-3	# handles the algorithm iteration counting
                                    	    76: 
02:00000000000000FF 8400100000      	    77: 	ldi r1,2		# a = 2
02:0000000000000104 D2008000007C0400	    78: 	stt r1,0xFFFC0004		# stores a
02:000000000000010C FCFF
                                    	    79: 
                                    	    80: floop: 
02:000000000000010E 44018000007C0400	    81: 	LDT r2,0xFFFC0004		# x = a
02:0000000000000116 FCFF
02:0000000000000118 8220102000      	    82: 	ADD r1,r1,r2					# a += x
02:000000000000011D D2008000007C0400	    83: 	STT r1,0xFFFC0004		# stores a
02:0000000000000125 FCFF
02:0000000000000127 52010000007C0000	    84: 	STT r2,0xFFFC0000		# stores x
02:000000000000012F FCFF
02:0000000000000131 8461F8FF07      	    85: 	ADD r3,r3,-1					# y -= 1
02:0000000000000136 276000ECFF      	    86:   bnez r3,floop		# jumps back to loop if Z bit != 0 (y's decremention isn't zero yet)
02:000000000000013B FFFFFFFFFF      	    87:   NOP
02:0000000000000140 FFFFFFFFFF      	    88:   NOP
02:0000000000000145 FFFFFFFFFF      	    89:   NOP
02:000000000000014A FFFFFFFFFF      	    90:   NOP
02:000000000000014F FFFFFFFFFF      	    91:   NOP
02:0000000000000154 FFFFFFFFFF      	    92: 	NOP  
                                    	    93: 	
                                    	    94: stall:
02:0000000000000159 2000000000      	    95: 	BRA	stall
                                    	    96: 
                                    	    97: # ------------------------------------------------------------------------------
                                    	    98: # Delay for a few seconds at startup.
                                    	    99: # ------------------------------------------------------------------------------
                                    	   100: 
                                    	   101: Delay3s:
02:000000000000015E 8400180000      	   102: 	ldi	a0,3	#000000
                                    	   103: .0001:
02:0000000000000163 5801400401      	   104: 	lsr	a1,a0,8
02:0000000000000168 520100E0077C00FF	   105: 	stt.io a1,leds
02:0000000000000170 DFFE
02:0000000000000172 8420F8FF07      	   106: 	sub	a0,a0,1
02:0000000000000177 2B2000F6FF      	   107: 	bgt	a0,r0,.0001	
                                    	   108: doRet:
02:000000000000017C A304000000      	   109: 	ret
                                    	   110: 
                                    	   111: #------------------------------------------------------------------------------
                                    	   112: # clearscreen
                                    	   113: # Parameters:
                                    	   114: # 	<none>
                                    	   115: # Modifies:
                                    	   116: #		<none>
                                    	   117: # Stack space:
                                    	   118: #		3 words
                                    	   119: #------------------------------------------------------------------------------
                                    	   120: 
                                    	   121: ClearScreen:
02:0000000000000181 36C2388001      	   122: 	push t0,t2,t3
02:0000000000000186 46020082007C1004	   123: 	ldo t0,TextAttr
02:000000000000018E FCFF
02:0000000000000190 0982000100      	   124: 	or t0,t0,' '
02:0000000000000195 8F03000000      	   125: 	mov t3,r0
02:000000000000019A 0403000002      	   126: 	ldi t2,64*8*32							# 64x32x8
                                    	   127: .st1:
02:000000000000019F 570238C0007C0000	   128: 	sto.io t0,txtscreen[r0+t3]
02:00000000000001A7 C0FE
02:00000000000001A9 84E3400000      	   129: 	add t3,t3,8
02:00000000000001AE 28E830F8FF      	   130: 	blt t3,t2,.st1
02:00000000000001B3 37C2388001      	   131: 	pop t0,t2,t3
02:00000000000001B8 A304000000      	   132: 	ret
                                    	   133: 
                                    	   134: #------------------------------------------------------------------------------
                                    	   135: # Calculate screen memory location from CursorRow,CursorCol.
                                    	   136: # Returns:
                                    	   137: #		a0 = screen location
                                    	   138: # Stack space:
                                    	   139: #		1 word
                                    	   140: #------------------------------------------------------------------------------
                                    	   141: 
                                    	   142: CalcScreenLoc:
02:00000000000001BD 3601008000      	   143: 	push a1
02:00000000000001C2 C0000080007C0004	   144: 	ldb	a0,CursorRow			# cursor row
02:00000000000001CA FCFF
02:00000000000001CC 8820F80300      	   145: 	and a0,a0,0x7f
02:00000000000001D1 40016080007C0304	   146: 	ldb a1,TextCols				# times number of columns
02:00000000000001D9 FCFF
02:00000000000001DB 8220108000      	   147: 	mul a0,a0,a1
02:00000000000001E0 40012080007C0104	   148: 	ldb a1,CursorCol			# plus cursor col
02:00000000000001E8 FCFF
02:00000000000001EA 0841F80300      	   149: 	and a1,a1,0x7f
02:00000000000001EF 8220102000      	   150: 	add a0,a0,a1
02:00000000000001F4 D1008080007C0404	   151: 	stw a0,TextCurpos			# update text position
02:00000000000001FC FCFF
02:00000000000001FE D800180001      	   152: 	asl a0,a0,3						# multiply by text cell size
02:0000000000000203 45010081007C0804	   153: 	ldtu a1,TextScr				# add in text screen location
02:000000000000020B FCFF
02:000000000000020D 8220102000      	   154: 	add a0,a0,a1
02:0000000000000212 3701008000      	   155: 	pop a1
02:0000000000000217 A304000000      	   156: 	ret
                                    	   157: 
                                    	   158: #------------------------------------------------------------------------------
                                    	   159: # Display a character on the screen
                                    	   160: #
                                    	   161: # Parameters:
                                    	   162: # 	a1 = char to display
                                    	   163: # Modifies:
                                    	   164: #		screen and text cursor position updated
                                    	   165: #------------------------------------------------------------------------------
                                    	   166: 
                                    	   167: DisplayChar:
02:000000000000021C B61C008000      	   168: 	push lr1
02:0000000000000221 2758F811007C0D00	   169: 	bne a1,'\r',.0010				# carriage return?
02:0000000000000229 0000
02:000000000000022B 50002080007C0104	   170: 	stb r0,CursorCol				# just set cursor column to zero on a CR
02:0000000000000233 FCFF
02:0000000000000235 A076070000      	   171: 	bsr SyncCursor
02:000000000000023A B71C008000      	   172: 	pop lr1
02:000000000000023F A304000000      	   173: 	ret
                                    	   174: .0010:
02:0000000000000244 B640185002      	   175: 	push a0,a1,a2,a3
02:0000000000000249 0841F80700      	   176: 	and a1,a1,0xff					# make char unsigned
02:000000000000024E 2758F825007C9100	   177: 	bne a1,0x91,.0005				# cursor right?
02:0000000000000256 0000
                                    	   178: 	# Cursor right
02:0000000000000258 C0002080007C0104	   179: 	ldb a0,CursorCol				# Is rightmost column reached?
02:0000000000000260 FCFF
02:0000000000000262 C0016080007C0304	   180: 	ldb a2,TextCols
02:000000000000026A FCFF
02:000000000000026C 8461F8FF07      	   181: 	sub a2,a2,1
02:0000000000000271 2928180C00      	   182: 	bge a0,a2,.0001
02:0000000000000276 8420080000      	   183: 	add	a0,a0,1							# not rightmost, add 1 to column
02:000000000000027B D0002080007C0104	   184: 	stb a0,CursorCol
02:0000000000000283 FCFF
                                    	   185: .0002:
02:0000000000000285 A0D6060000      	   186: 	bsr SyncCursor
                                    	   187: .0001:
02:000000000000028A B740185002      	   188: 	pop a0,a1,a2,a3
02:000000000000028F B71C008000      	   189: 	pop lr1
02:0000000000000294 A304000000      	   190: 	ret
                                    	   191: .0005:
02:0000000000000299 2748F817007C9000	   192: 	bne a1,0x90,.0006
02:00000000000002A1 0000
                                    	   193: 	# Cursor up
02:00000000000002A3 C0000080007C0004	   194: 	ldb a0,CursorRow				# can the cursor move up?
02:00000000000002AB FCFF
02:00000000000002AD 262800EEFF      	   195: 	beq a0,r0,.0001
02:00000000000002B2 8420F8FF07      	   196: 	sub a0,a0,1
02:00000000000002B7 D0000080007C0004	   197: 	stb a0,CursorRow
02:00000000000002BF FCFF
02:00000000000002C1 2088FFFFFF      	   198: 	bra .0002
                                    	   199: .0006:
02:00000000000002C6 2748F817007C9300	   200: 	bne a1,0x93,.0007
02:00000000000002CE 0000
                                    	   201: 	# Cursor left
02:00000000000002D0 C0002080007C0104	   202: 	ldb a0,CursorCol				# can the cursor move left?
02:00000000000002D8 FCFF
02:00000000000002DA 262000D8FF      	   203: 	beq a0,r0,.0001	
02:00000000000002DF 8420F8FF07      	   204: 	sub a0,a0,1
02:00000000000002E4 D0002080007C0104	   205: 	stb a0,CursorCol
02:00000000000002EC FCFF
02:00000000000002EE 202EFFFFFF      	   206: 	bra .0002
                                    	   207: .0007:
02:00000000000002F3 2740F81F007C9200	   208: 	bne a1,0x92,.0008
02:00000000000002FB 0000
                                    	   209: 	# Cursor down
02:00000000000002FD C0000080007C0004	   210: 	ldb a0,CursorRow				# can cursor move down?
02:0000000000000305 FCFF
02:0000000000000307 C0014080007C0204	   211: 	ldb a2,TextRows
02:000000000000030F FCFF
02:0000000000000311 8461F8FF07      	   212: 	sub a2,a2,1
02:0000000000000316 292018BAFF      	   213: 	bge a0,a2,.0001
02:000000000000031B 8420080000      	   214: 	add a0,a0,1
02:0000000000000320 D0000080007C0004	   215: 	stb a0,CursorRow
02:0000000000000328 FCFF
02:000000000000032A 20B6FEFFFF      	   216: 	bra .0002
                                    	   217: .0008:										# home cursor
02:000000000000032F 2758F81B007C9400	   218: 	bne a1,0x94,.0011
02:0000000000000337 0000
                                    	   219: 	# Home cursor
02:0000000000000339 C0002080007C0104	   220: 	ldb a0,CursorCol
02:0000000000000341 FCFF
02:0000000000000343 2620000A00      	   221: 	beq a0,r0,.0003
02:0000000000000348 50002080007C0104	   222: 	stb r0,CursorCol
02:0000000000000350 FCFF
02:0000000000000352 2066FEFFFF      	   223: 	bra .0002
                                    	   224: .0003:
02:0000000000000357 50000080007C0004	   225: 	stb r0,CursorRow
02:000000000000035F FCFF
02:0000000000000361 2048FEFFFF      	   226: 	bra .0002
                                    	   227: .0011:
02:0000000000000366 2648F849007C9900	   228: 	beq a1,0x99,doDelete
02:000000000000036E 0000
02:0000000000000370 2650F82D007C0800	   229: 	beq a1,CTRLH,doBackspace
02:0000000000000378 0000
02:000000000000037A 2640F865007C1800	   230: 	beq a1,CTRLX,doCtrlX
02:0000000000000382 0000
02:0000000000000384 2640F81F007C0A00	   231: 	beq a1,'\n',.0012				# line feed
02:000000000000038C 0000
                                    	   232: 	# Regular char
02:000000000000038E A05EFCFFFF      	   233: 	bsr CalcScreenLoc				# a0 = screen location
02:0000000000000393 C6010082007C1004	   234: 	ldo a2,TextAttr
02:000000000000039B FCFF
02:000000000000039D 8261100800      	   235: 	or a2,a2,a1
02:00000000000003A2 D321000000      	   236: 	sto.io a2,[a0]
02:00000000000003A7 A0B8010000      	   237: 	bsr IncCursorPos
                                    	   238: .0004:
02:00000000000003AC A088040000      	   239: 	bsr SyncCursor
02:00000000000003B1 B740185002      	   240: 	pop a0,a1,a2,a3
02:00000000000003B6 B71C008000      	   241: 	pop lr1
02:00000000000003BB A304000000      	   242: 	ret
                                    	   243: .0012:										# line feed
02:00000000000003C0 A012020000      	   244: 	bsr IncCursorRow
02:00000000000003C5 20CEFFFFFF      	   245: 	bra .0004
                                    	   246: 			
                                    	   247: 	#---------------------------
                                    	   248: 	# CTRL-H: backspace
                                    	   249: 	#---------------------------
                                    	   250: doBackspace:
02:00000000000003CA C0002080007C0104	   251: 	ldb a0,CursorCol				# At start of line already?
02:00000000000003D2 FCFF
02:00000000000003D4 2720080A00      	   252: 	bne a0,a0,.0001
02:00000000000003D9 B740185002      	   253: 	pop a0,a1,a2,a3
02:00000000000003DE B71C008000      	   254: 	pop lr1
02:00000000000003E3 A304000000      	   255: 	ret
                                    	   256: .0001:
02:00000000000003E8 8420F8FF07      	   257: 	sub a0,a0,1							#decrement column
02:00000000000003ED D0002080007C0104	   258: 	stb a0,CursorCol
02:00000000000003F5 FCFF
                                    	   259: 
                                    	   260: 	#---------------------------
                                    	   261: 	# Delete key
                                    	   262: 	#---------------------------
                                    	   263: doDelete:
02:00000000000003F7 A08CFBFFFF      	   264: 	bsr	CalcScreenLoc				# a0 = screen location
02:00000000000003FC C0012080007C0104	   265: 	ldb a2,CursorCol
02:0000000000000404 FCFF
02:0000000000000406 40146080007C0304	   266: 	ldb a3,TextCols
02:000000000000040E FCFF
                                    	   267: .0001:
02:0000000000000410 4621000100      	   268: 	ldo a1,8[a0]
02:0000000000000415 5321000000      	   269: 	sto.io a1,[a0]
02:000000000000041A 8420400000      	   270: 	add a0,a0,8
02:000000000000041F 8461080000      	   271: 	add a2,a2,1
02:0000000000000424 286040F7FF      	   272: 	blt a2,a3,.0001
02:0000000000000429 0401000100      	   273: 	ldi a1,' '							# one space
02:000000000000042E 502100FF07      	   274: 	stb.io a1,-8[a0]				# terminate line with space char
02:0000000000000433 B740185002      	   275: 	pop a0,a1,a2,a3
02:0000000000000438 B71C008000      	   276: 	pop lr1
02:000000000000043D A304000000      	   277: 	ret
                                    	   278: 
                                    	   279: 	#---------------------------
                                    	   280: 	# CTRL-X: erase line
                                    	   281: 	#---------------------------
                                    	   282: doCtrlX:
02:0000000000000442 50002080007C0104	   283: 	stb r0,CursorCol			# Reset cursor to start of line
02:000000000000044A FCFF
02:000000000000044C C0006080007C0304	   284: 	ldb a0,TextCols				# and display TextCols number of spaces
02:0000000000000454 FCFF
02:0000000000000456 0401000100      	   285: 	ldi	a1,' '						# one space
                                    	   286: .0001:
                                    	   287: 	# DisplayChar is called recursively here
                                    	   288: 	# It's safe to do because we know it won't recurse again due to the
                                    	   289: 	# fact we know the character being displayed is a space char
02:000000000000045B A082FBFFFF      	   290: 	bsr DisplayChar
02:0000000000000460 8420F8FF07      	   291: 	sub a0,a0,1
02:0000000000000465 293000FAFF      	   292: 	bge a0,r0,.0001
02:000000000000046A 50002080007C0104	   293: 	stb r0,CursorCol			# Reset cursor to start of line
02:0000000000000472 FCFF
02:0000000000000474 B740185002      	   294: 	pop a0,a1,a2,a3
02:0000000000000479 B71C008000      	   295: 	pop lr1
02:000000000000047E A304000000      	   296: 	ret										# we're done
                                    	   297: 
                                    	   298: #------------------------------------------------------------------------------
                                    	   299: # Increment the cursor position, scroll the screen if needed.
                                    	   300: #------------------------------------------------------------------------------
                                    	   301: #
                                    	   302: IncCursorPos:
02:0000000000000483 B640000001      	   303: 	push a0,a1
02:0000000000000488 C0002080007C0104	   304: 	ldb a0,CursorCol
02:0000000000000490 FCFF
02:0000000000000492 8420080000      	   305: 	add a0,a0,1
02:0000000000000497 D0002080007C0104	   306: 	stb a0,CursorCol
02:000000000000049F FCFF
02:00000000000004A1 C0006080007C0304	   307: 	ldb a0,TextCols
02:00000000000004A9 FCFF
02:00000000000004AB 40012080007C0104	   308: 	ldb a1,CursorCol
02:00000000000004B3 FCFF
02:00000000000004B5 2840083200      	   309: 	blt a1,a0,IncCursorPos1	# return if text cols not exceeded
02:00000000000004BA 50002080007C0104	   310: 	stb r0,CursorCol
02:00000000000004C2 FCFF
02:00000000000004C4 B740000001      	   311: 	pop a0,a1
                                    	   312: IncCursorRow:
02:00000000000004C9 B640000001      	   313: 	push a0,a1
02:00000000000004CE C0000080007C0004	   314: 	ldb a0,CursorRow
02:00000000000004D6 FCFF
02:00000000000004D8 8420080000      	   315: 	add a0,a0,1
02:00000000000004DD D0000080007C0004	   316: 	stb a0,CursorRow
02:00000000000004E5 FCFF
02:00000000000004E7 40014080007C0204	   317: 	ldb a1,TextRows
02:00000000000004EF FCFF
02:00000000000004F1 2820101400      	   318: 	blt a0,a1,IncCursorPos1	# return if text rows not exceeded
02:00000000000004F6 0441F8FF07      	   319: 	sub a1,a1,1
02:00000000000004FB 50010080007C0004	   320: 	stb a1,CursorRow
02:0000000000000503 FCFF
02:0000000000000505 B61C008000      	   321: 	push lr1
02:000000000000050A A066F9FFFF      	   322: 	bsr CalcScreenLoc
02:000000000000050F A028000000      	   323: 	bsr ScrollUp
02:0000000000000514 B71C008000      	   324: 	pop lr1
                                    	   325: IncCursorPos1:
02:0000000000000519 B740000001      	   326: 	pop	a0,a1
02:000000000000051E A304000000      	   327: 	ret
                                    	   328: 
                                    	   329: #------------------------------------------------------------------------------
                                    	   330: # Scroll text screen
                                    	   331: #------------------------------------------------------------------------------
                                    	   332: 
                                    	   333: ScrollUp:
02:0000000000000523 B69C000001      	   334: 	push lr1,t0
02:0000000000000528 B640185002      	   335: 	push a0,a1,a2,a3
02:000000000000052D C4000081007C0804	   336: 	ldt a0,TextScr				# a0 = pointer to screen
02:0000000000000535 FCFF
02:0000000000000537 40016080007C0304	   337: 	ldb a1,TextCols				# a1 = number of columns
02:000000000000053F FCFF
02:0000000000000541 C0014080007C0204	   338: 	ldb a2,TextRows
02:0000000000000549 FCFF
02:000000000000054B 8461F8FF07      	   339: 	sub a2,a2,1
02:0000000000000550 8241188000      	   340: 	mul a2,a1,a2					# a2 = number of cells to move
02:0000000000000555 0F54000000      	   341: 	mov a3,a1
                                    	   342: .0001:
02:000000000000055A 4F22808101      	   343: 	ldo t0,[a0+a3]
02:000000000000055F 0214152800      	   344: 	sub a3,a3,a1
02:0000000000000564 572280C100      	   345: 	sto.io t0,[a0+a3]
02:0000000000000569 0214152000      	   346: 	add a3,a3,a1
02:000000000000056E 0214152000      	   347: 	add a3,a3,a1
02:0000000000000573 8461F8FF07      	   348: 	sub a2,a2,1
02:0000000000000578 2B7000F0FF      	   349: 	bgt a2,r0,.0001
02:000000000000057D A028000000      	   350: 	bsr BlankLastLine
02:0000000000000582 B740185002      	   351: 	pop a0,a1,a2,a3
02:0000000000000587 B79C000001      	   352: 	pop lr1,t0
02:000000000000058C A304000000      	   353: 	ret
                                    	   354: 
                                    	   355: #------------------------------------------------------------------------------
                                    	   356: # Blank out the last line of the screen.
                                    	   357: #------------------------------------------------------------------------------
                                    	   358: 
                                    	   359: BlankLastLine:
02:0000000000000591 3622100602      	   360: 	push t0,a0,a1,a2
02:0000000000000596 C4000081007C0804	   361: 	ldt a0,TextScr
02:000000000000059E FCFF
02:00000000000005A0 40016080007C0304	   362: 	ldb a1,TextCols
02:00000000000005A8 FCFF
02:00000000000005AA C0014080007C0204	   363: 	ldb a2,TextRows
02:00000000000005B2 FCFF
02:00000000000005B4 8461F8FF07      	   364: 	sub a2,a2,1
02:00000000000005B9 0241188000      	   365: 	mul a1,a1,a2
02:00000000000005BE 5801180001      	   366: 	asl a1,a1,3
02:00000000000005C3 0402000100      	   367: 	ldi t0,' '
02:00000000000005C8 C0016080007C0304	   368: 	ldb a2,TextCols
02:00000000000005D0 FCFF
                                    	   369: .0001:
02:00000000000005D2 5722100000      	   370: 	stb.io t0,[a0+a1]
02:00000000000005D7 0441400000      	   371: 	add a1,a1,8
02:00000000000005DC 8461F8FF07      	   372: 	sub a2,a2,1
02:00000000000005E1 2B6800F8FF      	   373: 	bgt a2,r0,.0001
02:00000000000005E6 3722100602      	   374: 	pop t0,a0,a1,a2
02:00000000000005EB A304000000      	   375: 	ret	
                                    	   376: 
                                    	   377: #------------------------------------------------------------------------------
                                    	   378: # SyncCursor:
                                    	   379: #
                                    	   380: # Sync the hardware cursor's position to the text cursor position.
                                    	   381: #
                                    	   382: # Parameters:
                                    	   383: #		<none>
                                    	   384: # Returns:
                                    	   385: #		<none>
                                    	   386: # Registers Affected:
                                    	   387: #		<none>
                                    	   388: #------------------------------------------------------------------------------
                                    	   389: 
                                    	   390: SyncCursor:
02:00000000000005F0 B600008000      	   391: 	push a0
02:00000000000005F5 C2008080007C0404	   392: 	ldw a0,TextCurpos
02:00000000000005FD FCFF
02:00000000000005FF D1008004007C2400	   393: 	stw.io a0,0xfec80024
02:0000000000000607 C8FE
02:0000000000000609 B700008000      	   394: 	pop a0
02:000000000000060E A304000000      	   395: 	ret
                                    	   396: 	
                                    	   397: #------------------------------------------------------------------------------
                                    	   398: # Display string on screen
                                    	   399: #
                                    	   400: # Parameters:
                                    	   401: # 	a0 = pointer to string to display
                                    	   402: # Returns:
                                    	   403: #		<none>
                                    	   404: # Modifies:
                                    	   405: #		<none>
                                    	   406: #------------------------------------------------------------------------------
                                    	   407: 
                                    	   408: DisplayString:
02:0000000000000613 B63C108001      	   409: 	push lr1,a0,a1
                                    	   410: .0002:
02:0000000000000618 4021000000      	   411: 	ldb a1,[a0]
02:000000000000061D 2640000A00      	   412: 	beq a1,r0,.0001
02:0000000000000622 A0F4F7FFFF      	   413: 	bsr DisplayChar
02:0000000000000627 8420080000      	   414: 	add a0,a0,1
02:000000000000062C 20D8FFFFFF      	   415: 	bra .0002
                                    	   416: .0001:
02:0000000000000631 B73C108001      	   417: 	pop lr1,a0,a1
02:0000000000000636 A304000000      	   418: 	ret
                                    	   419: 
                                    	   420: 	.include "serial.asm"

Source: "serial.asm"
                                    	     1: # ============================================================================
                                    	     2: #        __
                                    	     3: #   \\__/ o\    (C) 2022-2023  Robert Finch, Waterloo
                                    	     4: #    \  __ /    All rights reserved.
                                    	     5: #     \/_//     robfinch<remove>@finitron.ca
                                    	     6: #       ||
                                    	     7: #  
                                    	     8: #
                                    	     9: # Serial port routines for a WDC6551 compatible circuit.
                                    	    10: #
                                    	    11: # ============================================================================
                                    	    12: #
                                    	    13: 	.bss
00:000000000000000A 00              	    14: 	.space	10
00:000000000000000B *
                                    	    15: .set XON,0x11
                                    	    16: .set XOFF,0x13
                                    	    17: .set ACIA_RX,0xFED00000
                                    	    18: .set ACIA_TX,0xFED00000
                                    	    19: .set ACIA_STAT,0xFED00004
                                    	    20: .set ACIA_CMD,0xFED00008
                                    	    21: .set ACIA_CTRL,0xFED0000C
                                    	    22: .set SerTailRcv,0xFFFC0000
                                    	    23: .set SerHeadRcv,0xFFFC0004
                                    	    24: .set SerTailXmit,0xFFFC0008
                                    	    25: .set SerHeadXmit,0xFFFC000C
                                    	    26: .set SerRcvXon,0xFFFC0010
                                    	    27: .set SerRcvXoff,0xFFFC0011
                                    	    28: .set SerRcvBuf,0xFFFC1000
                                    	    29: .set uart,0xFED00000
                                    	    30: 
                                    	    31: 	.text
                                    	    32: #------------------------------------------------------------------------------
                                    	    33: # Initialize serial port.
                                    	    34: #
                                    	    35: # Clear buffer indexes. Two bytes are used for the buffer index even though
                                    	    36: # only a single byte is needed. This is for convenience in calculating the
                                    	    37: # number of characters in the buffer, done later. The upper byte remains at
                                    	    38: # zero.
                                    	    39: # The port is initialized for 9600 baud, 1 stop bit and 8 bits data sent.
                                    	    40: # The internal baud rate generator is used.
                                    	    41: #
                                    	    42: # Parameters:
                                    	    43: #		none
                                    	    44: # Modifies:
                                    	    45: #		a0
                                    	    46: # Returns:
                                    	    47: #		none
                                    	    48: #------------------------------------------------------------------------------
                                    	    49: 
                                    	    50: InitSerial:
                                    	    51: SerialInit:
02:000000000000063B 52008000007C0400	    52: 	stt		r0,SerHeadRcv
02:0000000000000643 FCFF
02:0000000000000645 52000000007C0000	    53: 	stt		r0,SerTailRcv
02:000000000000064D FCFF
02:000000000000064F 52008001007C0C00	    54: 	stt		r0,SerHeadXmit
02:0000000000000657 FCFF
02:0000000000000659 52000001007C0800	    55: 	stt		r0,SerTailXmit
02:0000000000000661 FCFF
02:0000000000000663 50000002007C1000	    56: 	stb		r0,SerRcvXon
02:000000000000066B FCFF
02:000000000000066D 50002002007C1100	    57: 	stb		r0,SerRcvXoff
02:0000000000000675 FCFF
                                    	    58: #	lda		COREID
                                    	    59: #sini1:
                                    	    60: #	cmpa	IOFocusID
                                    	    61: #	bne		sini1
                                    	    62: #	orcc	#$290						; mask off interrupts
                                    	    63: #	ldd		#ACIA_MMU				; map ACIA into address space
                                    	    64: #	std		MMU
02:0000000000000677 8400480000      	    65: 	ldi	a0,0x09					# dtr,rts active, rxint enabled (bit 1=0), no parity
02:000000000000067C D2000001007C0800	    66: 	stt.io a0,ACIA_CMD
02:0000000000000684 D0FE
02:0000000000000686 8400F000007C1E00	    67: 	ldi	a0,0x6001E			# baud 9600, 1 stop bit, 8 bit, internal baud gen
02:000000000000068E 0600
02:0000000000000690 D2008001007C0C00	    68: 	stt.io a0,ACIA_CTRL		# disable fifos (bit zero, one), reset fifos
02:0000000000000698 D0FE
                                    	    69: #	ldd		#$000F00				; map out ACIA
                                    	    70: #	std		MMU
02:000000000000069A A304000000      	    71: 	ret
                                    	    72: 
                                    	    73: #------------------------------------------------------------------------------
                                    	    74: # Calculate number of character in input buffer.
                                    	    75: #
                                    	    76: # Parameters:
                                    	    77: #		none
                                    	    78: # Returns:
                                    	    79: #		a0 = number of bytes in buffer.
                                    	    80: #------------------------------------------------------------------------------
                                    	    81: 
                                    	    82: SerialRcvCount:
02:000000000000069F 3661000001      	    83: 	push a1,a2
02:00000000000006A4 8F00000000      	    84: 	mov	a0,r0
02:00000000000006A9 45010000007C0000	    85: 	ldtu a1,SerTailRcv
02:00000000000006B1 FCFF
02:00000000000006B3 C5018000007C0400	    86: 	ldtu a2,SerHeadRcv
02:00000000000006BB FCFF
02:00000000000006BD 8240182800      	    87: 	sub	a0,a1,a2
02:00000000000006C2 2920001400      	    88: 	bge	a0,r0,.srcXit
02:00000000000006C7 8400008000      	    89: 	ldi	a0,0x1000
02:00000000000006CC C5018000007C0400	    90: 	ldtu a2,SerHeadRcv
02:00000000000006D4 FCFF
02:00000000000006D6 45010000007C0000	    91: 	ldtu a1,SerTailRcv
02:00000000000006DE FCFF
02:00000000000006E0 8220182800      	    92: 	sub	a0,a0,a2
02:00000000000006E5 8220102000      	    93: 	add	a0,a0,a1
                                    	    94: .srcXit:
02:00000000000006EA 3761000001      	    95: 	pop a1,a2
02:00000000000006EF A304000000      	    96: 	ret
                                    	    97: 
                                    	    98: #------------------------------------------------------------------------------
                                    	    99: # SerialGetChar
                                    	   100: #
                                    	   101: # Check the serial port buffer to see if there's a char available. If there's
                                    	   102: # a char available then return it. If the buffer is almost empty then send an
                                    	   103: # XON.
                                    	   104: #
                                    	   105: # Stack Space:
                                    	   106: #		4 words
                                    	   107: # Parameters:
                                    	   108: #		none
                                    	   109: # Modifies:
                                    	   110: #		none
                                    	   111: # Returns:
                                    	   112: #		a0 = character or -1
                                    	   113: #------------------------------------------------------------------------------
                                    	   114: 
                                    	   115: SerialGetChar:
02:00000000000006F4 B65C188001      	   116: 	push lr1,a1,a2
02:00000000000006F9 8400400000      	   117: 	ldi	a0,8							# bit 3=machine interrupt enable, mask off interrupts
02:00000000000006FE 8721208007      	   118: 	csrrc	a2,a0,0x3004		# status reg
02:0000000000000703 FFFFFFFFFF      	   119: 	nop
02:0000000000000708 FFFFFFFFFF      	   120: 	nop
02:000000000000070D FFFFFFFFFF      	   121: 	nop
02:0000000000000712 FFFFFFFFFF      	   122: 	nop
02:0000000000000717 FFFFFFFFFF      	   123: 	nop
02:000000000000071C FFFFFFFFFF      	   124: 	nop
02:0000000000000721 FFFFFFFFFF      	   125: 	nop
02:0000000000000726 FFFFFFFFFF      	   126: 	nop
02:000000000000072B A0E8FEFFFF      	   127: 	bsr	SerialRcvCount			# check number of chars in receive buffer
02:0000000000000730 2B38F81B007C0800	   128: 	bgt	a0,8,.sgc2
02:0000000000000738 0000
02:000000000000073A C0000002007C1000	   129: 	ldb	a0,SerRcvXon			# skip sending XON if already sent
02:0000000000000742 FCFF
02:0000000000000744 2738001000      	   130: 	bnez a0,.sgc2        	# XON already sent?
02:0000000000000749 8400880000      	   131: 	ldi	a0,XON						# if <8 send an XON
02:000000000000074E 50002002007C1100	   132: 	stb	r0,SerRcvXoff			# clear XOFF status
02:0000000000000756 FCFF
02:0000000000000758 D0000002007C1000	   133: 	stb	a0,SerRcvXon			# flag so we don't send it multiple times
02:0000000000000760 FCFF
02:0000000000000762 A0CC010000      	   134: 	bsr	SerialPutChar
                                    	   135: .sgc2:
02:0000000000000767 C5008000007C0400	   136: 	ldtu a0,SerHeadRcv		# check if anything is in buffer
02:000000000000076F FCFF
02:0000000000000771 45010000007C0000	   137: 	ldtu a1,SerTailRcv
02:0000000000000779 FCFF
02:000000000000077B 2620101E00      	   138: 	beq	a0,a1,.sgcNoChars
02:0000000000000780 0F21000000      	   139: 	mov	a1,a0
02:0000000000000785 C1400000027C0010	   140: 	ldbu a0,SerRcvBuf[a1]	# get byte from buffer
02:000000000000078D FCFF7C00000000
02:0000000000000794 0441080000      	   141: 	add	a1,a1,1
02:0000000000000799 0841F87F00      	   142: 	and	a1,a1,0xfff				# 4k wrap around
02:000000000000079E 52018000007C0400	   143: 	stt	a1,SerHeadRcv
02:00000000000007A6 FCFF
02:00000000000007A8 0760208003      	   144: 	csrrw	r0,a2,0x3004		# restore interrupts
02:00000000000007AD B75C188001      	   145: 	pop lr1,a1,a2
02:00000000000007B2 A304000000      	   146: 	ret
                                    	   147: .sgcNoChars:
02:00000000000007B7 8400F8FF07      	   148: 	ldi	a0,-1							#-1
02:00000000000007BC 0760208003      	   149: 	csrrw	r0,a2,0x3004		# restore interrupts
02:00000000000007C1 B75C188001      	   150: 	pop lr1,a1,a2
02:00000000000007C6 A304000000      	   151: 	ret
                                    	   152: 
                                    	   153: #------------------------------------------------------------------------------
                                    	   154: # SerialPeekChar
                                    	   155: #
                                    	   156: # Check the serial port buffer to see if there's a char available. If there's
                                    	   157: # a char available then return it. But don't update the buffer indexes. No need
                                    	   158: # to send an XON here.
                                    	   159: #
                                    	   160: # Stack Space:
                                    	   161: #		3 words
                                    	   162: # Parameters:
                                    	   163: #		none
                                    	   164: # Modifies:
                                    	   165: #		none
                                    	   166: # Returns:
                                    	   167: #		a0 = character or -1
                                    	   168: #------------------------------------------------------------------------------
                                    	   169: 
                                    	   170: SerialPeekChar:
                                    	   171: #	orcc	#$290							; mask off interrupts
02:00000000000007CB 3601008000      	   172: 	push a1
02:00000000000007D0 FAFF070000      	   173: 	atom 07777
02:00000000000007D5 C5008000007C0400	   174: 	ldtu a0,SerHeadRcv			# check if anything is in buffer
02:00000000000007DD FCFF
02:00000000000007DF 45010000007C0000	   175: 	ldtu a1,SerTailRcv
02:00000000000007E7 FCFF
02:00000000000007E9 2630100E00      	   176: 	beq	a0,a1,.spcNoChars		# no?
02:00000000000007EE C1200000027C0010	   177: 	ldbu a0,SerRcvBuf[a0]		# get byte from buffer
02:00000000000007F6 FCFF7C00000000
02:00000000000007FD 3701008000      	   178: 	pop a1
02:0000000000000802 A304000000      	   179: 	ret
                                    	   180: .spcNoChars:
02:0000000000000807 8400F8FF07      	   181: 	ldi	a0,-1
02:000000000000080C 3701008000      	   182: 	pop a1
02:0000000000000811 A304000000      	   183: 	ret
                                    	   184: 
                                    	   185: #------------------------------------------------------------------------------
                                    	   186: # SerialPeekChar
                                    	   187: #		Get a character directly from the I/O port. This bypasses the input
                                    	   188: # buffer.
                                    	   189: #
                                    	   190: # Stack Space:
                                    	   191: #		3 words
                                    	   192: # Parameters:
                                    	   193: #		none
                                    	   194: # Modifies:
                                    	   195: #		a0
                                    	   196: # Returns:
                                    	   197: #		a0 = character or -1
                                    	   198: #------------------------------------------------------------------------------
                                    	   199: 
                                    	   200: SerialPeekCharDirect:
                                    	   201: #	lda		COREID					; Ensure we have the IO Focus
                                    	   202: #	cmpa	IOFocusID
                                    	   203: #	bne		spcd0001
                                    	   204: # Disallow interrupts between status read and rx read.
                                    	   205: #	orcc	#$290						; mask off interrupts
02:0000000000000816 FAFF3F0000      	   206: 	atom 077777
02:000000000000081B C1008000007C0400	   207: 	ldbu.io	a0,ACIA_STAT
02:0000000000000823 D0FE
02:0000000000000825 8820400000      	   208: 	and	a0,a0,8					# look for Rx not empty
02:000000000000082A 2620000A00      	   209: 	beq	a0,r0,.spcd0001
02:000000000000082F C1000000007C0000	   210: 	ldbu.io	a0,ACIA_RX
02:0000000000000837 D0FE
02:0000000000000839 A304000000      	   211: 	ret
                                    	   212: .spcd0001:
02:000000000000083E 8400F8FF07      	   213: 	ldi	a0,-1
02:0000000000000843 A304000000      	   214: 	ret
                                    	   215: 
                                    	   216: #------------------------------------------------------------------------------
                                    	   217: # SerialPutChar
                                    	   218: #    Put a character to the serial transmitter. This routine blocks until the
                                    	   219: # transmitter is empty. 
                                    	   220: #
                                    	   221: # Stack Space
                                    	   222: #		4 words
                                    	   223: # Parameters:
                                    	   224: #		a1 = character to put
                                    	   225: # Modifies:
                                    	   226: #		none
                                    	   227: #------------------------------------------------------------------------------
                                    	   228: 
                                    	   229: SerialPutChar:
                                    	   230: .spc0001:
                                    	   231: #	lda		COREID					; Ensure we have the IO Focus
                                    	   232: #	cmpa	IOFocusID
                                    	   233: #	bne		spc0001
                                    	   234: #	andcc	#$D6F						; provide a window for an interrupt to occur
                                    	   235: #	ldu		#ACIA_MMU
                                    	   236: #	orcc	#$290						; mask off interrupts
                                    	   237: 	# Between the status read and the transmit do not allow an
                                    	   238: 	# intervening interrupt.
02:0000000000000848 FAFF3F0000      	   239: 	atom 077777
02:000000000000084D C5008000007C0400	   240: 	ldtu.io a0,ACIA_STAT	# wait until the uart indicates tx empty
02:0000000000000855 D0FE
02:0000000000000857 8820800000      	   241: 	and	a0,a0,16					# bit #4 of the status reg
02:000000000000085C 262000F6FF      	   242: 	beq	a0,r0,.spc0001		# branch if transmitter is not empty
02:0000000000000861 52010000007C0000	   243: 	stt.io a1,ACIA_TX			# send the byte
02:0000000000000869 D0FE
02:000000000000086B A304000000      	   244: 	ret
                                    	   245: 
                                    	   246: #------------------------------------------------------------------------------
                                    	   247: # Serial IRQ routine
                                    	   248: #
                                    	   249: # Keeps looping as long as it finds characters in the ACIA recieve buffer/fifo.
                                    	   250: # Received characters are buffered. If the buffer becomes full, new characters
                                    	   251: # will be lost.
                                    	   252: #
                                    	   253: # Stack Space:
                                    	   254: #		1 word
                                    	   255: # Parameters:
                                    	   256: #		none
                                    	   257: # Modifies:
                                    	   258: #		d,x
                                    	   259: # Returns:
                                    	   260: #		none
                                    	   261: #------------------------------------------------------------------------------
                                    	   262: 
                                    	   263: SerialIRQ:
                                    	   264: #	lda		$2000+$D3				; Serial active interrupt flag
                                    	   265: #	beq		notSerInt
                                    	   266: .sirqNxtByte:
02:0000000000000870 C4008000007C0400	   267: 	ldt.io a0,ACIA_STAT			# look for IRQs
02:0000000000000878 D0FE
02:000000000000087A 2B28005200      	   268: 	bgt	a0,r0,.notSerInt	# quick test for any irqs
02:000000000000087F 8820400000      	   269: 	and	a0,a0,8						# check bit 3 = rx full (not empty)
02:0000000000000884 2638004C00      	   270: 	beq	a0,r0,.notRxInt1
02:0000000000000889 C1000000007C0000	   271: 	ldbu.io	a0,ACIA_RX				# get data from Rx buffer to clear interrupt
02:0000000000000891 D0FE
02:0000000000000893 45010000007C0000	   272: 	ldtu a1,SerTailRcv			# check if recieve buffer full
02:000000000000089B FCFF
02:000000000000089D 0441080000      	   273: 	add	a1,a1,1
02:00000000000008A2 0841F87F00      	   274: 	and	a1,a1,0xfff
02:00000000000008A7 C5018000007C0400	   275: 	ldtu a2,SerHeadRcv
02:00000000000008AF FCFF
02:00000000000008B1 2650183600      	   276: 	beq	a1,a2,.sirqRxFull
02:00000000000008B6 52010000007C0000	   277: 	stt	a1,SerTailRcv			# update tail pointer
02:00000000000008BE FCFF
02:00000000000008C0 0441F8FF07      	   278: 	sub	a1,a1,1						# backup
02:00000000000008C5 0841F87F00      	   279: 	and	a1,a1,0xfff
02:00000000000008CA D0400000027C0010	   280: 	stb	a0,SerRcvBuf[a1]	# store recieved byte in buffer
02:00000000000008D2 FCFF7C00000000
02:00000000000008D9 C1002002007C1100	   281: 	ldbu a0,SerRcvXoff			# check if xoff already sent
02:00000000000008E1 FCFF
02:00000000000008E3 272800C6FF      	   282: 	bne	a0,r0,.sirqNxtByte
02:00000000000008E8 A06EFBFFFF      	   283: 	bsr	SerialRcvCount		# if more than 4070 chars in buffer
02:00000000000008ED 2838F8C1FF7CE60F	   284: 	blt	a0,4070,.sirqNxtByte
02:00000000000008F5 0000
02:00000000000008F7 8400980000      	   285: 	ldi	a0,XOFF						# send an XOFF
02:00000000000008FC 50000002007C1000	   286: 	stb	r0,SerRcvXon			# clear XON status
02:0000000000000904 FCFF
02:0000000000000906 D0002002007C1100	   287: 	stb	a0,SerRcvXoff			# set XOFF status
02:000000000000090E FCFF
02:0000000000000910 D0000000007C0000	   288: 	stb.io a0,ACIA_TX
02:0000000000000918 D0FE
02:000000000000091A 20ACFEFFFF      	   289: 	bra	.sirqNxtByte     	# check the status for another byte
                                    	   290: 	# Process other serial IRQs
                                    	   291: .notRxInt1:
                                    	   292: .sirqRxFull:
                                    	   293: .notRxInt:
                                    	   294: .notSerInt:
02:000000000000091F A304000000      	   295: 	ret
                                    	   296: 
                                    	   297: #------------------------------------------------------------------------------
                                    	   298: # Put a string to the serial port.
                                    	   299: #
                                    	   300: # Parameters:
                                    	   301: #		a0 = pointer to string
                                    	   302: # Modifies:
                                    	   303: #		none
                                    	   304: # Returns:
                                    	   305: #		none
                                    	   306: #------------------------------------------------------------------------------
                                    	   307: 
                                    	   308: SerialPutString:
02:0000000000000924 B63C105002      	   309: 	push lr1,a0,a1,a3
02:0000000000000929 0F34000000      	   310: 	mov	a3,a0
                                    	   311: .sps2:
02:000000000000092E 4001060000      	   312: 	ldb	a1,[a3]
02:0000000000000933 2640000A00      	   313: 	beq	a1,r0,.spsXit
02:0000000000000938 04140D0000      	   314: 	add	a3,a3,1
02:000000000000093D A016FEFFFF      	   315: 	bsr	SerialPutChar
02:0000000000000942 20D8FFFFFF      	   316: 	bra	.sps2
                                    	   317: .spsXit:
02:0000000000000947 B73C105002      	   318: 	pop lr1,a0,a1,a3
02:000000000000094C A304000000      	   319: 	ret
                                    	   320: 
                                    	   321: #------------------------------------------------------------------------------
                                    	   322: #------------------------------------------------------------------------------
                                    	   323: 
                                    	   324: SerialTest:
                                    	   325: .0001:
02:0000000000000951 0401080200      	   326: 	ldi a1,'A'
02:0000000000000956 A0E4FDFFFF      	   327: 	bsr SerialPutChar
02:000000000000095B 20ECFFFFFF      	   328: 	bra .0001
                                    	   329: 
                                    	   330: #nmeSerial:
                                    	   331: #	fcb		"Serial",0
                                    	   332: 
                                    	   333: .global SerialInit
                                    	   334: .global SerialPutString
                                    	   335: .global SerialTest
                                    	   336: 

Source: "boot.asm"
                                    	   421: 
                                    	   422: 	.balign	0x100,0xff
                                    	   423: 	
                                    	   424: 	.rodata
                                    	   425: msgStart:
03:0000000000000000 54686F7232303234	   426: 	.byte "Thor2024 System Starting.",0
03:0000000000000008 2053797374656D20
03:0000000000000010 5374617274696E67
03:0000000000000018 2E
03:0000000000000019 00
                                    	   427: 
03:000000000000001A 00              	   428: 	.org 0xffe0
03:000000000000001B *
                                    	   429: 	# initial machine stack pointer
03:000000000000FFE0 F0FFFCFFFFFFFFFF	   430: 	.8byte	0xFFFFFFFFFFFCFFF0
03:000000000000FFE8 FFFFFFFFFFFFFFFF	   431: 	.8byte	0xFFFFFFFFFFFFFFFF
                                    	   432: 	# initial program counter
03:000000000000FFF0 000000D0FFFFFFFF	   433: 	.8byte	0xFFFFFFFFD0000000
03:000000000000FFF8 FFFFFFFFFFFFFFFF	   434: 	.8byte	0xFFFFFFFFFFFFFFFF
                                    	   435: 
                                    	   436: 	.global Delay3s
                                    	   437: 
                                    	   438: 


Symbols by name:
.notRxInt                       02:000000000000091F
.notRxInt1                      02:000000000000091F
.notSerInt                      02:000000000000091F
.sgc2                           02:0000000000000767
.sgcNoChars                     02:00000000000007B7
.sirqNxtByte                    02:0000000000000870
.sirqRxFull                     02:000000000000091F
.spc0001                        02:0000000000000848
.spcNoChars                     02:0000000000000807
.spcd0001                       02:000000000000083E
.sps2                           02:000000000000092E
.spsXit                         02:0000000000000947
.srcXit                         02:00000000000006EA
.st1                            02:000000000000019F
.st2                            02:00000000000000B4
ACIA_CMD                         S:00000000FED00008
ACIA_CTRL                        S:00000000FED0000C
ACIA_RX                          S:00000000FED00000
ACIA_STAT                        S:00000000FED00004
ACIA_TX                          S:00000000FED00000
BlankLastLine                   02:0000000000000591
CTRLH                            S:0000000000000008
CTRLX                            S:0000000000000018
CalcScreenLoc                   02:00000000000001BD
ClearScreen                     02:0000000000000181
CursorCol                        S:00000000FFFC0401
CursorRow                        S:00000000FFFC0400
Delay3s                         02:000000000000015E EXP
DisplayChar                     02:000000000000021C
DisplayString                   02:0000000000000613
IncCursorPos                    02:0000000000000483
IncCursorPos1                   02:0000000000000519
IncCursorRow                    02:00000000000004C9
InitSerial                      02:000000000000063B
ScrollUp                        02:0000000000000523
SerHeadRcv                       S:00000000FFFC0004
SerHeadXmit                      S:00000000FFFC000C
SerRcvBuf                        S:00000000FFFC1000
SerRcvXoff                       S:00000000FFFC0011
SerRcvXon                        S:00000000FFFC0010
SerTailRcv                       S:00000000FFFC0000
SerTailXmit                      S:00000000FFFC0008
SerialGetChar                   02:00000000000006F4
SerialIRQ                       02:0000000000000870
SerialInit                      02:000000000000063B EXP
SerialPeekChar                  02:00000000000007CB
SerialPeekCharDirect            02:0000000000000816
SerialPutChar                   02:0000000000000848
SerialPutString                 02:0000000000000924 EXP
SerialRcvCount                  02:000000000000069F
SerialTest                      02:0000000000000951 EXP
SyncCursor                      02:00000000000005F0
TextAttr                         S:00000000FFFC0410
TextCols                         S:00000000FFFC0403
TextCurpos                       S:00000000FFFC0404
TextRows                         S:00000000FFFC0402
TextScr                          S:00000000FFFC0408
XOFF                             S:0000000000000013
XON                              S:0000000000000011
ary                              S:00000000FFFC0000
doBackspace                     02:00000000000003CA
doCtrlX                         02:0000000000000442
doDelete                        02:00000000000003F7
doRet                           02:000000000000017C
floop                           02:000000000000010E
leds                             S:00000000FEDFFF00
msgStart                        03:0000000000000000
stall                           02:0000000000000159
start                           02:0000000000000000
txtscreen                        S:00000000FEC00000

Symbols by value:
00000000FEC00000 txtscreen
00000000FED00000 ACIA_RX
00000000FED00000 ACIA_TX
00000000FED00004 ACIA_STAT
00000000FED00008 ACIA_CMD
00000000FED0000C ACIA_CTRL
00000000FEDFFF00 leds
00000000FFFC0000 ary
00000000FFFC0000 SerTailRcv
00000000FFFC0004 SerHeadRcv
00000000FFFC0008 SerTailXmit
00000000FFFC000C SerHeadXmit
00000000FFFC0010 SerRcvXon
00000000FFFC0011 SerRcvXoff
00000000FFFC0400 CursorRow
00000000FFFC0401 CursorCol
00000000FFFC0402 TextRows
00000000FFFC0403 TextCols
00000000FFFC0404 TextCurpos
00000000FFFC0408 TextScr
00000000FFFC0410 TextAttr
00000000FFFC1000 SerRcvBuf
0000000000000000 msgStart
0000000000000000 start
0000000000000008 CTRLH
0000000000000011 XON
0000000000000013 XOFF
0000000000000018 CTRLX
00000000000000B4 .st2
000000000000010E floop
0000000000000159 stall
000000000000015E Delay3s
000000000000017C doRet
0000000000000181 ClearScreen
000000000000019F .st1
00000000000001BD CalcScreenLoc
000000000000021C DisplayChar
00000000000003CA doBackspace
00000000000003F7 doDelete
0000000000000442 doCtrlX
0000000000000483 IncCursorPos
00000000000004C9 IncCursorRow
0000000000000519 IncCursorPos1
0000000000000523 ScrollUp
0000000000000591 BlankLastLine
00000000000005F0 SyncCursor
0000000000000613 DisplayString
000000000000063B InitSerial
000000000000063B SerialInit
000000000000069F SerialRcvCount
00000000000006EA .srcXit
00000000000006F4 SerialGetChar
0000000000000767 .sgc2
00000000000007B7 .sgcNoChars
00000000000007CB SerialPeekChar
0000000000000807 .spcNoChars
0000000000000816 SerialPeekCharDirect
000000000000083E .spcd0001
0000000000000848 SerialPutChar
0000000000000848 .spc0001
0000000000000870 SerialIRQ
0000000000000870 .sirqNxtByte
000000000000091F .notRxInt
000000000000091F .notSerInt
000000000000091F .sirqRxFull
000000000000091F .notRxInt1
0000000000000924 SerialPutString
000000000000092E .sps2
0000000000000947 .spsXit
0000000000000951 SerialTest
